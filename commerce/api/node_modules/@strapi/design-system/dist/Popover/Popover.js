import * as o from "react";
import t from "prop-types";
import d from "styled-components";
import { useFloating as R, offset as $, shift as W, flip as T, autoUpdate as O } from "@floating-ui/react-dom";
import { Box as s } from "../Box/Box.js";
import { Portal as S } from "../Portal/Portal.js";
import { useIntersection as q } from "../helpers/useIntersection.js";
const L = [
  "top",
  "top-start",
  "top-end",
  "right",
  "right-start",
  "right-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end"
], z = d(s)`
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};
  z-index: 4;
  border: 1px solid ${({ theme: e }) => e.colors.neutral150};
  background: ${({ theme: e }) => e.colors.neutral0};
`, A = d(s)`
  // 16 is base base size, 3 is the factor to get closer to 40px and 5 is the number of elements visible in the list
  max-height: ${3 * 5}rem;
  overflow-y: auto;
  overflow-x: hidden;

  &::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }

  &::-webkit-scrollbar-track {
    background: ${({ theme: e }) => e.colors.neutral0};
  }

  &::-webkit-scrollbar-thumb {
    background: ${({ theme: e }) => e.colors.neutral150};
    border-radius: ${({ theme: e }) => e.borderRadius};
    margin-right: 10px;
  }
`, a = ({
  source: e,
  children: m,
  spacing: h,
  fullWidth: i,
  placement: b,
  onReachEnd: n,
  intersectionId: r,
  centered: g,
  ...w
}) => {
  const l = o.useRef(null), [v, x] = o.useState(void 0), { x: y, y: E, reference: p, floating: P, strategy: k } = R({
    strategy: "fixed",
    placement: g ? "bottom" : b,
    middleware: [
      $({
        mainAxis: h
      }),
      W(),
      T()
    ],
    whileElementsMounted: O
  });
  return o.useLayoutEffect(() => {
    p(e.current);
  }, [e, p]), o.useLayoutEffect(() => {
    i && x(e.current.offsetWidth);
  }, [i, e]), q(l, n, {
    selectorToWatch: `#${r}`,
    skipWhen: !r || !n
  }), /* @__PURE__ */ o.createElement(z, {
    ref: P,
    style: {
      left: y,
      top: E,
      position: k,
      width: v || void 0
    },
    hasRadius: !0,
    background: "neutral0",
    padding: 1
  }, /* @__PURE__ */ o.createElement(A, {
    ref: l,
    ...w
  }, m, r && n && /* @__PURE__ */ o.createElement(s, {
    id: r,
    width: "100%",
    height: "1px"
  })));
}, c = (e) => /* @__PURE__ */ o.createElement(S, null, /* @__PURE__ */ o.createElement(a, {
  ...e
})), f = {
  fullWidth: !1,
  intersectionId: void 0,
  onReachEnd: void 0,
  centered: !1,
  placement: "bottom-start",
  spacing: 0
}, u = {
  centered: t.bool,
  children: t.node.isRequired,
  fullWidth: t.bool,
  intersectionId: t.string,
  onReachEnd: t.func,
  placement: t.oneOf(L),
  source: t.shape({
    current: (typeof Element > "u" ? t.any : t.instanceOf(Element)).isRequired
  }).isRequired,
  spacing: t.number
};
a.propTypes = u;
a.defaultProps = f;
c.propTypes = u;
c.defaultProps = f;
export {
  L as POPOVER_PLACEMENTS,
  c as Popover
};
