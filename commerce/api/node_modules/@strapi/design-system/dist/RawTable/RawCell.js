import g, { useRef as w, useState as R, useLayoutEffect as N, useCallback as A } from "react";
import o from "prop-types";
import { Box as P } from "../Box/Box.js";
import { getFocusableNodes as l, getFocusableNodesWithKeyboardNav as b } from "../helpers/getFocusableNodes.js";
import { KeyboardKeys as d } from "../helpers/keyboardKeys.js";
import { useTable as B } from "./RawTableContext.js";
const E = (r) => /* @__PURE__ */ g.createElement(h, {
  ...r,
  as: "th"
}), h = ({ coords: r, as: T, ...x }) => {
  const s = w(null), { rowIndex: y, colIndex: v, setTableValues: p } = B(), [c, i] = R(!1), I = (e) => {
    const t = l(s.current, !0);
    if (t.length === 0 || t.length === 1 && b(t).length === 0)
      return;
    if (t.length > 1 && !t.find((u) => u.tagName !== "BUTTON")) {
      e.preventDefault();
      const u = t.findIndex((a) => a === document.activeElement);
      if (e.key === d.RIGHT) {
        const a = t[u + 1];
        a && (e.stopPropagation(), a.focus());
      } else if (e.key === d.LEFT) {
        const a = t[u - 1];
        a && (e.stopPropagation(), a.focus());
      }
      return;
    }
    const n = e.key === d.ENTER;
    if (n && !c)
      i(!0);
    else if ((e.key === d.ESCAPE || n) && c) {
      if (n && document.activeElement.tagName === "A")
        return;
      i(!1), s.current.focus();
    } else
      c && e.stopPropagation();
  }, f = y === r.row - 1 && v === r.col - 1;
  N(() => {
    const e = l(s.current, !0);
    e.length === 0 || e.length === 1 && b(e).length !== 0 || e.length > 1 && Boolean(e.find((t) => t.tagName !== "BUTTON")) ? (s.current.setAttribute("tabIndex", !c && f ? 0 : -1), e.forEach((t, n) => {
      t.setAttribute("tabIndex", c ? 0 : -1), c && n === 0 && t.focus();
    })) : e.forEach((t) => {
      t.setAttribute("tabIndex", f ? 0 : -1);
    });
  }, [c, f]);
  const m = A(() => {
    const e = l(s.current, !0);
    e.length >= 1 && (b(e).length !== 0 || !e.find((t) => t.tagName !== "BUTTON")) && i(!0), p({ rowIndex: r.row - 1, colIndex: r.col - 1 });
  }, [r, p]);
  return N(() => {
    const e = s.current;
    return l(e, !0).forEach((n) => {
      n.addEventListener("focus", m);
    }), () => {
      l(e, !0).forEach((u) => {
        u.removeEventListener("focus", m);
      });
    };
  }, [m]), /* @__PURE__ */ g.createElement(P, {
    role: "gridcell",
    as: T,
    ref: s,
    onKeyDown: I,
    ...x
  });
};
E.defaultProps = {
  children: void 0,
  coords: {}
};
E.propTypes = {
  "aria-colindex": o.number.isRequired,
  children: o.node,
  coords: o.shape({
    col: o.number,
    row: o.number
  })
};
h.defaultProps = {
  as: "td",
  children: void 0,
  coords: {}
};
h.propTypes = {
  "aria-colindex": o.number.isRequired,
  as: o.oneOf(["td", "th"]),
  children: o.node,
  coords: o.shape({
    col: o.number,
    row: o.number
  })
};
export {
  h as RawTd,
  E as RawTh
};
